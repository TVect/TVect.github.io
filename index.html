<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>PersonalBlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="PersonalBlog">
<meta property="og:url" content="http://tvect.cc/index.html">
<meta property="og:site_name" content="PersonalBlog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PersonalBlog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="PersonalBlog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Vect</a></h1>
		</hgroup>

		
		<p class="header-subtitle">My Blog</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Vect</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="null" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Vect</h1>
			</hgroup>
			
			<p class="header-subtitle">My Blog</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-cache-alg" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/09/06/cache-alg/" class="article-date">
  	<time datetime="2016-09-05T22:47:49.000Z" itemprop="datePublished">9月 6 2016</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/06/cache-alg/">缓存替换策略对比测试</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<p>缓存替换策略对比测试<br>下面首先将Greedy-Dual Size和几种常见的缓存替换策略进行了对比，参与对比的缓存策略有：<br>RandomDiscard: 随机替换<br>    FirstInFirstOut: 先进先出<br>    LeastRecentlyUsed(LRU): 最近最少使用置换算法,也就是首先淘汰最长时间未被使用的项<br>    LeastFrequentlyUsed(LFU): 最近最不常用置换算法,也就是淘汰一定时期内被访问次数最少的项<br>之后，也对Greedy-Dual Size中不同的priority计算方式进行了效果测试。</p>
<h1 id="Greedy-Dual-Size简介："><a href="#Greedy-Dual-Size简介：" class="headerlink" title="Greedy-Dual Size简介："></a>Greedy-Dual Size简介：</h1><p>传统的cache替换，像CPU caches和Virtual Memory处理的都是缓存项大小一致的情况，在我们的场景中，我们要缓存的数据大小是会在很大的范围内变化的，从下面的实验数据中可以看到，我们要缓存的数据尺寸大部分集中在1M，2M以下，但是也会出现几百兆大小的文件。</p>
<p>RandomDiscard，FirstInFirstOut，LeastRecentlyUsed(LRU)，LeastFrequentlyUsed(LFU)，乃至GD算法中都没有考虑到size的影响。</p>
<p>在Greedy-Dual算法中，给每个缓存项赋予权重priority=clock + cost。<br>在Greedy-Dual Size算法的原始形式中，给每个缓存项赋予权重priority=clock+cost/size。<br>其中clock用来控制衰老，cost表示获取文件的代价，size表示文件的大小。<br>从Greedy-Dual和Greedy-Dual Size中对priority的不同赋值，可以看出，Greedy-Dual试图贪婪地使得缓存的每一项价值足够大，而Greedy-Dual Size则试图使得缓存的每一个字节的价值足够大。<br>所以，直观上感觉，在限定缓存字节上限的情况下，Greedy-Dual Size会比Greedy-Dual表现的更好。</p>
<h2 id="Greedy-Dual-Size基本步骤："><a href="#Greedy-Dual-Size基本步骤：" class="headerlink" title="Greedy-Dual Size基本步骤："></a>Greedy-Dual Size基本步骤：</h2><p>在本Greedy-Dual Size算法中，缓存权重计算公式设置为 $ P\left ( f \right ) = Clock + F \times \frac{Cost\left ( f \right )}{Size\left ( f \right )} $</p>
<p>其基本步骤如下：</p>
<ol>
<li>如果请求的file在cache中：<br>更新file访问次数 $F\left ( f \right ) = F \left ( f \right ) + 1$<br>更新file缓存权重，并将其权重重新更新到优先级队列中</li>
<li><p>如果请求的file不在cache中，需要从来源去取file，并<br>设置file的访问次数为 $F\left ( f \right ) = 1 $<br>计算file的权重，并将其权重插入到优先级队列中<br>更新cache使用情况： $Used = Used + Size\left ( f \right )$<br>2.1. 如果 $Used \leqslant Limit$ :<br>表明有足够的缓存空间，将file放到缓存中<br>2.2. 如果 $Used &gt; Limit$ :<br>从优先级队列中选择优先级最低的k个文件, 使得 $UsedEstimate \leqslant Limit$ , 其中<br>$$UsedEstimate = Used - \sum Size\left ( f{i} \right )$$<br> 2.2.1. 如果选取的k个文件中包含了file：<br> file不应该被缓存，从优先队列中剔除file相对应的权重<br> 2.2.2. 如果选择的k个文件中不包含file：<br> 更新 $Clock = max P\left ( f_{i} \right )$</p>
<p> 更新 $Used = Used - \sum Size\left ( f_{i} \right )$</p>
<p> 其中 $i \leq k$</p>
<p> 从缓存中移除折k个文件，并从优先队列中剔除这些被移除的文件的权重</p>
<p> 把file放到缓存中</p>
</li>
</ol>
<h1 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h1><p>在以下实验中，用limit_size表示测试环境中缓存字节数的上限。<br>使用了hit_percent和byte_hit_percent来比较不同算法，不同参数下的表现好坏。<br>hit_percent: 缓存命中比率，即为cache命中数除以数据请求总次数<br>byte_hit_percent: 字节缓存命中比率，即为cache命中的字节数除以总的请求的字节数</p>
<h2 id="实验基本数据："><a href="#实验基本数据：" class="headerlink" title="实验基本数据："></a>实验基本数据：</h2><p>实验中涉及到的数据包括：真实的每一套设计，每一套设计中包含的模型，每一个模型的大小。<br>实验数据均来源于真实环境，每次实验中可能会根据需要打乱设计的次序。</p>
<p>在实验数据中，模型size大小的分布情况图如下：<br><img src="http://obn75nm65.bkt.clouddn.com/model_size.png" alt="Alt text"></p>
<p>再将尺寸大小的数据用箱线图展示一下，如下图，下面的为放大后的局部图。<br><img src="http://obn75nm65.bkt.clouddn.com/model_size_1.png" alt="Alt text"><br><img src="http://obn75nm65.bkt.clouddn.com/model_size_2.png" alt="Alt text"><br>从上面的箱线图可以得到，平均值大约为5M，中位数大约为2M，上四分位数大约为7.5M，下四分位数大约为450K，上边缘大约为17.5M。<br>可是为什么箱线图告诉我会有这么多异常点？？？</p>
<p>在实验数据中，每个设计案例中含有的模型个数分布如下：<br><img src="http://obn75nm65.bkt.clouddn.com/model_dis.png" alt="Alt text"><br>同样也对每套设计中包括的模型数进行箱线图展现，结果如下所示，下面的是局部放大之后的图。<br><img src="http://obn75nm65.bkt.clouddn.com/model_dis_1.png" alt="Alt text"><br><img src="http://obn75nm65.bkt.clouddn.com/model_dis_2.png" alt="Alt text"><br>从下面的箱线图中可以得到，设计中含有的模型数量的平均值大约为29，中位数大约为23，上四分卫数大约为39，下四分位数大约为11，上边缘值大约为81，下边缘值大约为1。<br>不过还是感觉有很多异常值。</p>
<h2 id="实验一：测试以上几种算法在不同的limit-size情况下，缓存命中率，缓存字节命中率的差别"><a href="#实验一：测试以上几种算法在不同的limit-size情况下，缓存命中率，缓存字节命中率的差别" class="headerlink" title="实验一：测试以上几种算法在不同的limit_size情况下，缓存命中率，缓存字节命中率的差别"></a>实验一：测试以上几种算法在不同的limit_size情况下，缓存命中率，缓存字节命中率的差别</h2><p>实验环境：<br>总的请求个数为269962<br>去重后的请求个数为：8725<br>总的请求数据字节总数为：1 065 274 095 532byte，约为1TB<br>去重后的数据字节总数为：46 420 192 764byte，约为43.23GB<br>实验结果：<br>五种缓存替换算法，在不同的limit_size下，对应的缓存命中率hit_percent图示如下：<br><img src="http://obn75nm65.bkt.clouddn.com/hit-limit.png" alt="Alt text"></p>
<p>五种缓存替换算法，在不同的limit_size下，对应的字节缓存命中率byte_hit_percent图示如下：<br><img src="http://obn75nm65.bkt.clouddn.com/bytehit-limit.png" alt="Alt text"><br>实验结论：<br>通过以上两幅图，<br>横向来看，随着limit_size的增大，不同算法的两种命中率都有相应的提高。<br>纵向来看，GDS基本要优于LFU和LRU，而LFU和LRU又比Random和FIFO效果要好。</p>
<h2 id="实验二：测试GDS算法中，缓存项的不同priority计算方案对结果的影响"><a href="#实验二：测试GDS算法中，缓存项的不同priority计算方案对结果的影响" class="headerlink" title="实验二：测试GDS算法中，缓存项的不同priority计算方案对结果的影响"></a>实验二：测试GDS算法中，缓存项的不同priority计算方案对结果的影响</h2><p>实验中涉及到的priority计算方案有以下几种：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_priority_1</span><span class="params">(clock, freq, size)</span>:</span></span><br><span class="line">    cost = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> clock + freq * cost</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_priority_2</span><span class="params">(clock, freq, size)</span>:</span></span><br><span class="line">    cost = <span class="number">2</span> + size/<span class="number">536</span></span><br><span class="line">    <span class="keyword">return</span> clock + freq * cost</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_priority_3</span><span class="params">(clock, freq, size)</span>:</span></span><br><span class="line">    cost = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> clock + freq * cost / math.log(size)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_priority_4</span><span class="params">(clock, freq, size)</span>:</span></span><br><span class="line">    cost = <span class="number">2</span> + size/<span class="number">536</span></span><br><span class="line">    <span class="keyword">return</span> clock + freq * cost / math.log(size)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_priority_5</span><span class="params">(clock, freq, size)</span>:</span></span><br><span class="line">    cost = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> clock + freq * cost/float(size)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_priority_6</span><span class="params">(clock, freq, size)</span>:</span></span><br><span class="line">    cost = <span class="number">2</span> + size/<span class="number">536</span></span><br><span class="line">    <span class="keyword">return</span> clock + freq * cost/float(size)</span><br></pre></td></tr></table></figure></p>
<p>结果统计：<br><img src="http://obn75nm65.bkt.clouddn.com/priority-hit.png" alt="Alt text"><br><img src="http://obn75nm65.bkt.clouddn.com/priority-bytehit.png" alt="Alt text"></p>
<p>结果分析：<br>从hit_percent来看，method4和method2缓存命中率最低，从计算公式可以看到，这两种计算方法都比较倾向于缓存size较大的数据项，从而导致了在limit_size的限制下，缓存的数据项数目会比较少，导致缓存命中率较低。method5的缓存命中率最高，因为method5中倾向于缓存size较小的数据，导致缓存项会比较多，缓存命中率会相对比较高。<br><img src="http://obn75nm65.bkt.clouddn.com/priority-bytehit_detail.png" alt="Alt text"></p>
<p>从上边这张对 byte_hit_precent 进行放大的图中来看，<br>method5，method4，method2 相对于其他三种效果较差。</p>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>《Improving WWW proxies performance with Greedy-Dual-Size-Frequency caching policy》Ludmila Cherkasova<br>《基于WEB代理的访问控制网关系统研究与实现》张鑫<br>《Web缓冲存储器算法Greedy DualSize的分析与改进》杨相生</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-numpy-ndarray-view-copy" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/09/numpy-ndarray-view-copy/" class="article-date">
  	<time datetime="2016-08-09T12:30:34.104Z" itemprop="datePublished">8月 9 2016</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/09/numpy-ndarray-view-copy/">numpy ndarray类型中view/copy</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在numpy的reshape和ravel函数说明中指出在必要时会返回对象的拷贝。<br>numpy.reshape()中指出：</p>
<pre><code>This will be a new view object if possible; otherwise, it will be a copy.  
Note there is no guarantee of the *memory layout* (C- or Fortran- contiguous) of the returned array.
</code></pre><p>numpy.ravel()中指出：</p>
<pre><code>A 1-D array, containing the elements of the input, is returned.  A copy is made only if needed.
</code></pre><p>下面就自己的理解做一下解释。<br><br></p>
<h1 id="ndarray的内存结构"><a href="#ndarray的内存结构" class="headerlink" title="ndarray的内存结构"></a>ndarray的<a href="http://old.sebug.net/paper/books/scipydoc/numpy_intro.html" target="_blank" rel="external">内存结构</a></h1><p><img src="http://obn75nm65.bkt.clouddn.com/ndarry-memory.png" alt="ndarray内存结构" title="numpy ndarray"><br>数据存储区域保存着数组中所有元素的二进制数据，dtype对象则知道如何将元素的二进制数据转换为可用的值。数组的维数、大小等信息都保存在ndarray数组对象的数据结构中。</p>
<p>strides中保存的是当每个轴的下标增加1时，数据存储区中的指针所增加的字节数。例如图中的strides为12,4，即第0轴的下标增加1时，数据的地址增加12个字节：即a[1,0]的地址比a[0,0]的地址要高12个字节，正好是3个单精度浮点数的总字节数；第1轴下标增加1时，数据的地址增加4个字节，正好是单精度浮点数的字节数。</p>
<p>具体来说，<strong>在展示数组的时候会先根据data的起始地址和strides[0]的偏移大小，找到行首元素的位置，按照strides[1]的偏移大小，取出指定个数的元素，把他们作为一行展示出来</strong>。</p>
<p>另外，元素在数据存储区中的排列格式有两种：C语言格式和Fortan语言格式。在C语言中，多维数组的第0轴是最上位的，即第0轴的下标增加1时，元素的地址增加的字节数最多；而Fortan语言的多维数组的第0轴是最下位的，即第0轴的下标增加1时，地址只增加一个元素的字节数。在NumPy中，元素在内存中的排列缺省是以C语言格式存储的，如果你希望改为Fortan格式的话，只需要给数组传递order=”F”参数。</p>
<p><br></p>
<h1 id="案例分析："><a href="#案例分析：" class="headerlink" title="案例分析："></a>案例分析：</h1><h3 id="案例1：基本函数"><a href="#案例1：基本函数" class="headerlink" title="案例1：基本函数"></a>案例1：基本函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = a.view()  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c <span class="keyword">is</span> a  </span><br><span class="line"><span class="keyword">False</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.base <span class="keyword">is</span> a      <span class="comment">#c是a持有数据的镜像  </span></span><br><span class="line"><span class="keyword">True</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.flags.owndata  </span><br><span class="line"><span class="keyword">False</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.shape = <span class="number">2</span>,<span class="number">6</span>    <span class="comment"># a的形状没变  </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape  </span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="number">0</span>,<span class="number">4</span>] = <span class="number">1234</span>        <span class="comment">#a的数据改变了  </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a  </span><br><span class="line">array([[   <span class="number">0</span>,    <span class="number">1</span>,    <span class="number">2</span>,    <span class="number">3</span>],  </span><br><span class="line">       [<span class="number">1234</span>,    <span class="number">5</span>,    <span class="number">6</span>,    <span class="number">7</span>],  </span><br><span class="line">       [   <span class="number">8</span>,    <span class="number">9</span>,   <span class="number">10</span>,   <span class="number">11</span>]])</span><br></pre></td></tr></table></figure>
<h3 id="案例2：reshape返回view还是copy？"><a href="#案例2：reshape返回view还是copy？" class="headerlink" title="案例2：reshape返回view还是copy？"></a>案例2：reshape返回view还是copy？</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> arr.strides, arr[::<span class="number">2</span>][::<span class="number">2</span>].strides    <span class="comment"># 返回view</span></span><br><span class="line">(<span class="number">16L</span>, <span class="number">4L</span>) (<span class="number">32L</span>, <span class="number">8L</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> arr.T.strides, arr.T[::<span class="number">2</span>][::<span class="number">2</span>].strides    <span class="comment"># 返回view</span></span><br><span class="line">(<span class="number">4L</span>, <span class="number">16L</span>) (<span class="number">8L</span>, <span class="number">32L</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> arr.T[::<span class="number">2</span>][::<span class="number">2</span>].base <span class="keyword">is</span> arr.base</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>brr = arr.T.reshape((<span class="number">12</span>,))    <span class="comment"># 返回的是copy，因为此时已经无法在不修改数据存储区域的基础上，仅仅通过修改dims，strides等信息，来构造新的结构了</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> brr.strides</span><br><span class="line">(<span class="number">4L</span>, )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> np.may_share_memory(arr, brr)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> brr.base <span class="keyword">is</span> arr.base</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="案例3：flatten和ravel操作对比"><a href="#案例3：flatten和ravel操作对比" class="headerlink" title="案例3：flatten和ravel操作对比"></a>案例3：flatten和ravel操作对比</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> np.may_share_memory(arr.flatten(), arr)    <span class="comment">#flatten：return a copy of the array collapsed into one dimension</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> np.may_share_memory(arr.ravel(), arr)    <span class="comment">#ravel：返回view</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> np.may_share_memory(arr.T.ravel(), arr)    <span class="comment">#ravel：返回copy</span></span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>解释：<br>成员函数.ravel()，等价于numpy.ravel()，其说明如下：</p>
<pre><code>Return a contiguous flattened array.
A 1-D array, containing the elements of the input, is returned.  A copy is made only if needed.
</code></pre><p>相比之下，flatten会一直返回对象的拷贝，而ravel一般会返回view，但会在必要的时候返回数据的copy.<br>在上面的例子中arr.T.ravel()无法在不修改数据存储区域的基础上，仅仅通过修改dims，strides等信息，来构造新的结构，所以会返回一个数据的拷贝。</p>
<h3 id="案例4：resize操作成功还是失败？"><a href="#案例4：resize操作成功还是失败？" class="headerlink" title="案例4：resize操作成功还是失败？"></a>案例4：resize操作成功还是失败？</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = np.arange(<span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.resize(<span class="number">12</span>)    <span class="comment"># 注意成员函数resize，numpy通用函数resize的区别</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.resize((<span class="number">2</span>,<span class="number">4</span>)); <span class="keyword">print</span> arr    <span class="comment"># resize操作成功</span></span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = np.arange(<span class="number">8</span>); arr.resize(<span class="number">12</span>); brr = arr; arr.resize((<span class="number">2</span>,<span class="number">4</span>))    <span class="comment"># 失败</span></span><br><span class="line">ValueError: cannot resize an array that references <span class="keyword">or</span> <span class="keyword">is</span> referenced</span><br><span class="line">by another array <span class="keyword">in</span> this way.  Use the resize function</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = np.arange(<span class="number">8</span>); arr.resize(<span class="number">12</span>); brr = arr; np.resize(arr, (<span class="number">2</span>,<span class="number">4</span>))    <span class="comment"># 成功</span></span><br></pre></td></tr></table></figure>
<p>解释：<br>成员函数会抛出异常ValueError</p>
<pre><code>If `a` does not own its own data or references or views to it exist, and the data memory must be changed.
</code></pre><p>而通用函数numpy.resize(), 不会抛出上述异常。因为成员函数ndarray.resize()是对array进行原地修改的，而numpy.resize()则不会对原对象做修改，只是返回一个新的指定shape的array<br>另外，numpy.resize()和numpy.resize()还有如下不同：</p>
<pre><code>If the new array is larger than the original array, then the new array is filled with repeated copies of `a`.  
Note that this behavior is different from a.resize(new_shape) which fills with zeros instead of repeated copies of `a`.
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-numpy-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/24/numpy-1/" class="article-date">
  	<time datetime="2016-07-24T00:26:30.000Z" itemprop="datePublished">7月 24 2016</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/24/numpy-1/">numpy_1</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="NumPy数组对象"><a href="#NumPy数组对象" class="headerlink" title="NumPy数组对象"></a>NumPy数组对象</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>NumPy中的ndarray是一个多维数组对象，该对象由两部分组成：<br>    实际的数据；<br>    描述这些数据的元数据。<br>大部分的数组操作仅仅修改元数据部分，而不改变底层的实际数据。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>NumPy数组在数值运算方面的效率优于Python提供的list容器。<br>使用NumPy可以在代码中省去很多循环语句，因此其代码比等价的Python代码更为简洁。</p>
<h1 id="创建多维数组"><a href="#创建多维数组" class="headerlink" title="创建多维数组"></a>创建多维数组</h1><p>numpy.array([numpy.arange(2), numpy.arange(2)])</p>
<h1 id="自定义数据类型"><a href="#自定义数据类型" class="headerlink" title="自定义数据类型"></a>自定义数据类型</h1><p>numpy.dtype([(,name’, str_, 40), (‘numitems’, int32), (‘price’,float32)])</p>
<h1 id="数组的切片和索引"><a href="#数组的切片和索引" class="headerlink" title="数组的切片和索引"></a>数组的切片和索引</h1><p>numpy.arange(24).reshape((2,3,4))[0,…]</p>
<h3 id="Tips-…"><a href="#Tips-…" class="headerlink" title="Tips: …"></a>Tips: …</h3><pre><code>多个冒号可以用一个省略号...来代替,表示遍历剩下的维度
</code></pre><h1 id="改变数组的维度"><a href="#改变数组的维度" class="headerlink" title="改变数组的维度"></a>改变数组的维度</h1><h2 id="reshape-x-y"><a href="#reshape-x-y" class="headerlink" title=".reshape((x, y))"></a>.reshape((x, y))</h2><h2 id="用元组设置维度"><a href="#用元组设置维度" class="headerlink" title="用元组设置维度"></a>用元组设置维度</h2><p>b.shape = (2, 3)</p>
<h2 id="resize-x-y"><a href="#resize-x-y" class="headerlink" title=".resize((x, y))"></a>.resize((x, y))</h2><p>和reshape函数的功能一样，但resize会直接修改所操作的数组</p>
<h2 id="transponse"><a href="#transponse" class="headerlink" title=".transponse()"></a>.transponse()</h2><h2 id="展平操作"><a href="#展平操作" class="headerlink" title="展平操作"></a>展平操作</h2><pre><code>.ravel(): return a view of the original array
.flatten(): return a copy of the original array
</code></pre><h3 id="Tips-ravel-amp-flatten"><a href="#Tips-ravel-amp-flatten" class="headerlink" title="Tips: ravel &amp; flatten"></a>Tips: ravel &amp; flatten</h3><pre><code>The difference is that flatten always returns a copy and ravel returns a view of the original array whenever possible. This isn&apos;t visible in the printed output, but if you modify  the array returned by ravel, it may modify the entries in the original array. If you modify the entries in an array returned from flatten this will never happen. ravel will often be faster since no memory is copied, but you have to be more careful about modifying the array it returns.
</code></pre><h1 id="数组的组合"><a href="#数组的组合" class="headerlink" title="数组的组合"></a>数组的组合</h1><p>水平组合：np.hstack()<br>垂直组合：np.vstack()<br>深度组合：np.dstack()<br>列组合：np.column_stack()    而对于二维数组, column_stack与hstack的效果是相同的<br>行组合：np.row_stack()    对于二维数组, row_stack与vstack的效果是相同的<br>连接函数：np.concatenate((a1, a2, …), axis=0)    可以用concatenate实现hstack, vstack类似的效果</p>
<h1 id="数组的分割"><a href="#数组的分割" class="headerlink" title="数组的分割"></a>数组的分割</h1><p>水平分割：np.hsplit()<br>垂直分割：np.vsplit()<br>深度分割：np.dsplit()<br>split函数：numpy.split(ary, indices_or_sections, axis=0)</p>
<h1 id="数组的属性"><a href="#数组的属性" class="headerlink" title="数组的属性"></a>数组的属性</h1><p>shape属性<br>dtype属性<br>ndim属性：数组的维数<br>size属性：数组中元素的总个数<br>itemsize属性：数组中每个元素在内存中所占的字节数<br>nbytes属性：整个数组所占用的存储空间，即为itemsize*size<br>T属性：数组的转置，对于一维数组，其T属性就是原数组<br>real属性：给出复数数组的实部<br>imag属性：给出复数数组的虚部<br>flat属性：</p>
<pre><code>flat属性将返回一个numpy.flatiter对象，这是获得flatiter对象的唯一方式——我们无法访问flatiter的构造函数。
这个所谓的“扁平迭代器”可以让我们像遍历一维数组一样去遍历任意的多维数组。
可以用flatiter对象直接获取一个或多个数组元素。
flat属性是一个可赋值的属性。对flat属性赋值将导致整个数组的元素都被覆盖。
</code></pre><h1 id="数组的转换"><a href="#数组的转换" class="headerlink" title="数组的转换"></a>数组的转换</h1><p>.tolist()：转换成列表<br>.astype()：在转换数组时可以指定类型</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-process" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/28/process/" class="article-date">
  	<time datetime="2016-06-28T14:05:06.307Z" itemprop="datePublished">6月 28 2016</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/28/process/">multiprocessing</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###Pipe: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">link</a><br>The Pipe() function returns a pair of connection objects connected by a pipe which by default is duplex (two-way). For example:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Pipe</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(conn)</span>:</span></span><br><span class="line">    conn.send([<span class="number">42</span>, <span class="keyword">None</span>, <span class="string">'hello'</span>])</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parent_conn, child_conn = Pipe()</span><br><span class="line">    p = Process(target=f, args=(child_conn,))</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="keyword">print</span> parent_conn.recv()   <span class="comment"># prints "[42, None, 'hello']"</span></span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>
<p>The two connection objects returned by Pipe() represent the two ends of the pipe. Each connection object has send() and recv() methods (among others). Note that data in a pipe may become corrupted if two processes (or threads) try to read from or write to the same end of the pipe at the same time. Of course there is no risk of corruption from processes using different ends of the pipe at the same time.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/25/hello-world/" class="article-date">
  	<time datetime="2016-06-25T04:56:36.203Z" itemprop="datePublished">6月 25 2016</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/25/hello-world/">Hello World</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Vect
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>